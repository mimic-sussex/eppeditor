[{"2":{"fixed":false,"resizable":true,"draggable":true,"customDragger":false,"customResizer":false,"min":{"w":1,"h":1},"max":{},"x":1,"y":0,"w":1,"h":2},"3":{"fixed":false,"resizable":true,"draggable":true,"customDragger":false,"customResizer":false,"min":{"w":1,"h":1},"max":{},"x":2,"y":0,"w":1,"h":2},"6":{"fixed":false,"resizable":true,"draggable":true,"customDragger":false,"customResizer":false,"min":{"w":1,"h":1},"max":{},"x":0,"y":10,"w":3,"h":3},"8":{"fixed":false,"resizable":true,"draggable":true,"customDragger":false,"customResizer":false,"min":{"w":1,"h":1},"max":{},"x":3,"y":0,"w":2,"h":1,"id":"_pj7nx4if2"},"12":{"fixed":false,"resizable":true,"draggable":true,"customDragger":false,"customResizer":false,"min":{"w":1,"h":1},"max":{},"x":7,"y":0,"w":4,"h":4},"id":"_w00exs5bj","data":{"id":"_w00exs5bj","type":"analyser","name":"analyser_w00exs5bj","background":"#191919","lineNumbers":true,"hasFocus":true,"theme":"icecoder","mode":""},"hasFocus":false},{"2":{"fixed":false,"resizable":true,"draggable":true,"customDragger":false,"customResizer":false,"min":{"w":1,"h":1},"max":{},"x":0,"y":0,"w":1,"h":2},"3":{"fixed":false,"resizable":true,"draggable":true,"customDragger":false,"customResizer":false,"min":{"w":1,"h":1},"max":{},"x":0,"y":0,"w":2,"h":7,"id":"_cctdhevvf"},"6":{"fixed":false,"resizable":true,"draggable":true,"customDragger":false,"customResizer":false,"min":{"w":1,"h":1},"max":{},"x":0,"y":0,"w":4,"h":7,"id":"_cctdhevvf"},"8":{"fixed":false,"resizable":true,"draggable":true,"customDragger":false,"customResizer":false,"min":{"w":1,"h":1},"max":{},"x":0,"y":0,"w":3,"h":4,"id":"_2vyqpze52"},"12":{"fixed":false,"resizable":true,"draggable":true,"customDragger":false,"customResizer":false,"min":{"w":1,"h":1},"max":{},"x":0,"y":0,"w":7,"h":7,"id":"_cctdhevvf"},"id":"_9614xc9dk","data":{"id":"_9614xc9dk","type":"liveCodeEditor","name":"liveCodeEditor_9614xc9dk","background":"#151515","lineNumbers":true,"hasFocus":true,"theme":"icecoder","grammarSource":"/languages/default/grammar.ne","liveCodeSource":"","content":"{120, 4}clk;\n:numnotes:{{1}clt, [1], [8, 12, 4, 6]}rsq; //sequence of number of pulses per pattern\n{{16}clt, 1, [16, :numnotes:], 2}toJS;//sequencer clock, inc, [sequence length, number of active pulses in sequence], packet size to JS\n:rhy:{{0}fromJS}onzx; //recieve either 0 for off or 1, zero crossing based\n// :rhy:{{0}fromJS, 0}gt; //recieve when trig is 1, has a different feel\n:kick:{{4}clt,1}\\909b;\n:hats:{:rhy:}\\909closed;\n>{:kick:, :hats:}mix;","grammar":"# Lexer [or tokenizer] definition with language lexemes [or tokens]\n@{%\n\nconst lexer = moo.compile({\n  separator:      /,/,\n  paramEnd:       /}/,\n  paramBegin:     /{/,\n  listEnd:        /\\]/,\n  listBegin:      /\\[/,\n  dacoutCh:       /\\>[0-9]+/,\n  dacout:         /\\>/,\n  variable:       /:[a-zA-Z0-9]+:/,\n  sample:         { match: /\\\\[a-zA-Z0-9]+/, lineBreaks: true, value: x => x.slice(1, x.length)},\n  slice:          { match: /\\|[a-zA-Z0-9]+/, lineBreaks: true, value: x => x.slice(1, x.length)},\n  stretch:        { match: /\\@[a-zA-Z0-9]+/, lineBreaks: true, value: x => x.slice(1, x.length)},\n  clockTrig:      /0t-?(?:[0-9]|[1-9][0-9]+)(?:\\.[0-9]+)?\\b/,\n\tnumber:         /-?(?:[0-9]|[1-9][0-9]+)(?:\\.[0-9]+)?\\b/,\n  semicolon:      /;/,\n  funcName:       /[a-zA-Z][a-zA-Z0-9]*/,\n\tstring:\t\t\t\t\t{ match: /'[a-zA-Z0-9]+'/, value: x => x.slice(1,x.length-1)},\n  comment:        /\\/\\/[^\\n]*/,\n  ws:             { match: /\\s+/, lineBreaks: true},\n});\n\n%}\n\n# Pass your lexer object using the @lexer option\n@lexer lexer\n\n# Grammar definition in the Extended Backus Naur Form (EBNF)\nmain -> _ Statement _\n{% d => ( { '@lang' : d[1] } )  %}\n\nStatement ->\n  %comment _ Statement\n  {% d => d[2] %}\n\t|\n  Expression _ %semicolon _ Statement\n  {% d => [ { '@spawn': d[0] } ].concat(d[4]) %}\n  |\n  Expression _ %semicolon (_ %comment):*\n  {% d => [ { '@spawn': d[0] } ] %}\n\n\nExpression ->\n  ParameterList _ %funcName\n  {% d => sema.synth( d[2].value, d[0]['@params'] ) %}\n  |\n  ParameterList _ %sample\n  {% d => sema.synth( 'sampler', d[0]['@params'].concat( [ sema.str( d[2].value ) ] ) ) %}\n  |\n  ParameterList _ %slice\n  {% d => sema.synth( 'slice', d[0]['@params'].concat( [ sema.str( d[2].value ) ] ) ) %}\n  |\n  ParameterList _ %stretch\n  {% d => sema.synth( 'stretch', d[0]['@params'].concat( [ sema.str( d[2].value ) ] ) ) %}\n  |\n  %variable _ Expression\n  {% d => sema.setvar( d[0].value, d[2] ) %}\n  |\n  %dacout _ Expression\n  {% d => sema.synth( 'dac', [d[2]] ) %}\n  |\n  %dacoutCh _ Expression\n  {% d => sema.synth( 'dac', [d[2], sema.num(d[0].value.substr(1))] ) %}\n\nParameterList ->\n  %paramBegin Params %paramEnd\n  {% d => ( { 'paramBegin': d[0], '@params': d[1], 'paramEnd': d[2] } ) %}\n\t|\n\t%paramBegin _ %paramEnd\n  {% d => ( { 'paramBegin': d[0], '@params': [], 'paramEnd': d[2] } ) %}\n\n\nParams ->\n  ParamElement\n  {% d => ( [ d[0] ] ) %}\n  |\n  ParamElement _ %separator _ Params\n  {% d => [ d[0] ].concat(d[4]) %}\n\nParamElement ->\n  %number\n  {% d => ( { '@num': d[0] } ) %}\n\t|\n\t%string\n  {% d => ( { '@string': d[0].value } ) %}\n  |\n  Expression\n  {% id %}\n  |\n  %variable\n  {% d => sema.getvar( d[0].value ) %}\n  |\n  %listBegin Params  %listEnd\n  {% d => ( { '@list': d[1] } )%}\n\n\n# Whitespace\n\n_  -> wschar:*\n{% function(d) {return null;} %}\n\n__ -> wschar:+\n{% function(d) {return null;} %}\n\nwschar -> %ws\n{% id %}\n"},"hasFocus":true},{"2":{"fixed":false,"resizable":true,"draggable":true,"customDragger":false,"customResizer":false,"min":{"w":1,"h":1},"max":{},"x":0,"y":2,"w":1,"h":2},"3":{"fixed":false,"resizable":true,"draggable":true,"customDragger":false,"customResizer":false,"min":{"w":1,"h":1},"max":{},"x":0,"y":7,"w":2,"h":2},"6":{"fixed":false,"resizable":true,"draggable":true,"customDragger":false,"customResizer":false,"min":{"w":1,"h":1},"max":{},"x":0,"y":7,"w":4,"h":3},"8":{"fixed":false,"resizable":true,"draggable":true,"customDragger":false,"customResizer":false,"min":{"w":1,"h":1},"max":{},"x":3,"y":1,"w":4,"h":5,"id":"_hcppuzblk"},"12":{"fixed":false,"resizable":true,"draggable":true,"customDragger":false,"customResizer":false,"min":{"w":1,"h":1},"max":{},"x":0,"y":7,"w":8,"h":5},"id":"_rbycy6zdv","data":{"id":"_rbycy6zdv","type":"modelEditor","name":"modelEditor_rbycy6zdv","background":"#151515","lineNumbers":true,"hasFocus":true,"theme":"monokai","content":"//Euclidean Rhythm Generator\n//based on euclidean sequencer algorithm from:\n//https://lookmumnocomputer.discourse.group/t/euclidean-rhythm-generator-arduino-based/470\nvar channel0 = createOutputChannel(0, 1);\n___\nvar noteLength=50;\nvar pos=16;\nvar inputBuffer=[0,0,0];\nvar quotient=0;\nvar remainder=0;\nvar skip = 0;\nvar updateFlag=false;\nvar inputLength=0;\nvar lastInputLength=8;\nvar inputNotes=0;\nvar lastInputNotes=4;\n___\nvar seqBuffer= new Array(32);\ninput = (id,x) => {\n\t//channel0.send(0);\n\tfor (i in x){\n\t\tinputBuffer[i]=x[i];\n\t}\n\tinputLength=inputBuffer[0];\n\tinputNotes=inputBuffer[1];\n\tif (inputLength>seqBuffer.length){\n\t\tinputLength=seqBuffer.length;\n\t}\t\n\tif (inputNotes>=inputLength){\n\t\tinputNotes=inputLength;\n\t}\n\tif (inputNotes!=lastInputNotes){\n\t\tlastInputNotes=inputNotes;\n\t\tupdateFlag = true;\n\t}\n\tif (inputLength!=lastInputLength){\n\t\tlastInputLength=inputLength;\n\t\tupdateFlag=true;\n\t}\n\tif (updateFlag){\n\t\tfor (e in seqBuffer){\n\t\t\tseqBuffer[e] = 0;\n\t\t}\n\t\tskip=0;\n\t\tremainder=inputNotes;\n\t\twhile(remainder>0){\n\t\t\tquotient=floor(inputLength/remainder);\n\t\t\tlet rem=inputLength%remainder;\n\t\t\tif(rem){quotient+=1;}\n\t\t\tfor (var i = 0; i < inputLength;i++) {\n\t\t\t\tlet testSlot=(i+1)%quotient;\n\t\t\t\tif (testSlot == 1) {\n\t\t\t\t\tlet bufferAddr=(i+skip)%inputLength;\n\t\t\t\t\tseqBuffer[bufferAddr]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tskip+=1;\n\t\t\tremainder-=floor(inputLength/quotient);\n\t\t}\n\t\tupdateFlag = false;\n\t\t//console.log(seqBuffer); //uncomment to see buffer in console, -1 os off, 1 is on due to zero crossing;\n\t} \n\tpos++;\n\tif (updateFlag == false){\n\tif (inputLength==inputNotes){\n\t\tchannel0.send(1);\n\t} else {\n\t\tif (pos>inputLength-1){pos=0;}\n\t\t\tchannel0.send(seqBuffer[pos]);\n\t\t}\n\t}\n}"},"hasFocus":false}]